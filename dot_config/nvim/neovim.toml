[[plugins]]
repo = 'tversteeg/registers.nvim'
lua_post_source = '''
require('registers').setup {}
'''

[[plugins]]
repo = 'folke/which-key.nvim'

# [[plugins]]
# repo = 'kevinhwang91/nvim-hlslens'
# hook_add = '''
# noremap <silent> n <Cmd>execute('normal! ' . v:count1 . 'n')<CR><Cmd>lua require('hlslens').start()<CR>
# noremap <silent> N <Cmd>execute('normal! ' . v:count1 . 'N')<CR><Cmd>lua require('hlslens').start()<CR>
# noremap * *<Cmd>lua require('hlslens').start()<CR>
# noremap # #<Cmd>lua require('hlslens').start()<CR>
# noremap g* g*<Cmd>lua require('hlslens').start()<CR>
# noremap g# g#<Cmd>lua require('hlslens').start()<CR>
# nnoremap <silent> <Esc><Esc> <Cmd>nohlsearch<CR>
# '''

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
lua_post_source = '''
require('gitsigns').setup{
  current_line_blame = true,
  current_line_blame_opts = {
    virt_text = true,
    virt_text_pos = 'eol',
    delay = 1000
  },
  current_line_blame_formatter_opts = {
    relative_time = false
  },
  on_attach = function(bufnr)
    local gs = require("gitsigns")

    local function map(mode, l, r, opts)
      opts = opts or {}
      opts.buffer = bufnr
      vim.keymap.set(mode, l, r, opts)
    end

    map('n', ']c', function()
      if vim.wo.diff then return ']c' end
      vim.schedule(function() gs.next_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    map('n', '[c', function()
      if vim.wo.diff then return '[c' end
      vim.schedule(function() gs.prev_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    map('n', ']g', '<Cmd>Gitsigns stage_hunk<CR>')
    map('n', '[g', '<Cmd>Gitsigns undo_stage_hunk<CR>')
  end
}
'''

[[plugins]]
repo = 'nvim-lualine/lualine.nvim'
lua_post_source = '''
local function skkstatus()
  local alias = { [''] = 'A', hira = 'あ', kata = 'ア', hankata = 'ｱ', zenkaku = "Ａ", abbrev = '@' }
  return alias[vim.g['skkeleton#mode']]
end

local custom_nightfly = require'lualine.themes.nightfly'
custom_nightfly.insert.a.bg = custom_nightfly.normal.a.bg
custom_nightfly.visual.a.bg = custom_nightfly.normal.a.bg
custom_nightfly.normal.y = {}
custom_nightfly.normal.y.bg = custom_nightfly.normal.a.bg
custom_nightfly.normal.y.fg = custom_nightfly.normal.a.fg
custom_nightfly.insert.y = {}
custom_nightfly.insert.y.bg = custom_nightfly.normal.a.bg
custom_nightfly.insert.y.fg = custom_nightfly.normal.a.fg
custom_nightfly.normal.y = {}
custom_nightfly.normal.y.bg = custom_nightfly.normal.a.bg
custom_nightfly.normal.y.fg = custom_nightfly.normal.a.fg
custom_nightfly.command = {}
custom_nightfly.command.y = {}
custom_nightfly.command.y.bg = custom_nightfly.normal.a.bg
custom_nightfly.command.y.fg = custom_nightfly.normal.a.fg
custom_nightfly.insert.z = custom_nightfly.normal.b
custom_nightfly.normal.z = custom_nightfly.normal.b
custom_nightfly.command.z = custom_nightfly.normal.b

require'lualine'.setup {
  options = {
    icons_enabled = true,
    theme = custom_nightfly,
    component_separators = { left = '', right = ''},
    section_separators = { left = '', right = ''},
    always_divide_middle = true,
  },
  sections = {
    lualine_a = { 'mode', skkstatus },
    lualine_b = { { 'branch', separator = '', padding = { left = 1, right = 0 } }, { 'diff', colored = false, separator = '' }, { 'filename', path = 1, shorting_target = 30, icon_enabled = true, icon = '' } },
    lualine_c = {},
    lualine_x = { 'filetype', { 'encoding', separator = '', padding = { left = 1, right = 0 } }, 'fileformat' },
    lualine_y = {{ 'location', separator = '' }, {'progress', padding = { left = 0, right = 1 } }},
    lualine_z = {{ 'diagnostics', sources = {'nvim_diagnostic'}, colored = false, symbols = { error = 'E:', warn = 'W:', info = 'I', hint = 'H:' } }}
  },
  extensions = {'fern'}
}
vim.go.laststatus = 0
'''

[[plugins]]
repo = 'kyazdani42/nvim-web-devicons'

[[plugins]]
repo = 'romgrk/barbar.nvim'
hook_add = '''
  nnoremap <silent> <C-s> <Cmd>BufferPick<CR>
  nnoremap <silent> <S-TAB> <Cmd>BufferPrevious<CR>
  nnoremap <silent> <TAB> <Cmd>BufferNext<CR>
  nnoremap <silent> <A-1> :BufferGoto 1<CR>
  nnoremap <silent> <A-2> :BufferGoto 2<CR>
  nnoremap <silent> <A-3> :BufferGoto 3<CR>
  nnoremap <silent> <A-4> :BufferGoto 4<CR>
  nnoremap <silent> <A-5> :BufferGoto 5<CR>
  nnoremap <silent> <A-6> :BufferGoto 6<CR>
  nnoremap <silent> <A-7> :BufferGoto 7<CR>
  nnoremap <silent> <A-8> :BufferGoto 8<CR>
  nnoremap <silent> <A-9> :BufferLast<CR>
'''

[[plugins]]
repo = 'nvim-lua/popup.nvim'

[[plugins]]
repo = 'nvim-lua/plenary.nvim'

[[plugins]]
repo = 'phaazon/hop.nvim'
hook_post_source = '''
lua require'hop'.setup()
'''
lua_add = '''
vim.keymap.set('n', 'gff', require'hop'.hint_words)
'''

[[plugins]]
repo = 'b3nj5m1n/kommentary'
lua_post_source = '''
require('kommentary.config').configure_language("typescriptreact", {
  single_line_comment_string = "//",
  multi_line_comment_strings = {"{/*", "*/}"}
})
'''

[[plugins]]
repo = 'kwkarlwang/bufresize.nvim'

[[plugins]]
repo = 'aserowy/tmux.nvim'
lua_post_source = '''
require('tmux').setup({
  navigation = {
    enable_default_keybindings = true,
  },
  copy_sync = {
    enable = false,
  },
})
'''

[[plugins]]
repo = 'MunifTanjim/nui.nvim'

[[plugins]]
repo = 'zah/nim.vim'

[[plugins]]
repo = 'gamoutatsumi/orgmode'
rev = 'feature/support-emacsclient'
lua_post_source = '''
require('orgmode').setup_ts_grammar()
require('orgmode').setup {
  org_agenda_files = {'~/Google Drive/マイドライブ/org/*', '~/Repositories/github.com/gamoutatsumi/my-orgs/**/*'},
  org_default_notes_file = '~/Google Drive/マイドライブ/org/refile.org',
}
'''

[[plugins]]
repo = 'levouh/tint.nvim'
lua_post_source = '''
require('tint').setup {}
'''

[[plugins]]
repo = 'uga-rosa/ccc.nvim'
lua_post_source = '''
require('ccc').setup {}
'''

[[plugins]]
repo = 'rcarriga/nvim-notify'
lua_post_source = '''
  require('notify').setup {
    background_colour = "#000000",
  }
'''

[[plugins]]
repo = 'folke/noice.nvim'
lazy = 1
on_event = ["VimEnter"]
depends = ['nui.nvim', 'nvim-notify']
lua_post_source = '''
  require("noice").setup {
  }
'''

[[plugins]]
repo = 'j-hui/fidget.nvim'
rev = 'legacy'
lua_post_source = '''
require('fidget').setup {}
'''

[[plugins]]
repo = 'monaqa/dial.nvim'
lua_add = '''
vim.api.nvim_set_keymap("n", "<C-a>", require("dial.map").inc_normal(), {noremap = true})
vim.api.nvim_set_keymap("n", "<C-x>", require("dial.map").dec_normal(), {noremap = true})
vim.api.nvim_set_keymap("v", "<C-a>", require("dial.map").inc_visual(), {noremap = true})
vim.api.nvim_set_keymap("v", "<C-x>", require("dial.map").dec_visual(), {noremap = true})
vim.api.nvim_set_keymap("v", "g<C-a>", require("dial.map").inc_gvisual(), {noremap = true})
vim.api.nvim_set_keymap("v", "g<C-x>", require("dial.map").dec_gvisual(), {noremap = true})
'''

[[plugins]]
repo = 'ray-x/guihua.lua'

[[plugins]]
repo = 'ruifm/gitlinker.nvim'
lua_post_source = '''
require('gitlinker').setup()
'''

[[plugins]]
repo = 'folke/neodev.nvim'

[[plugins]]
repo = 'stevearc/aerial.nvim'
lua_post_source = '''
-- Call the setup function to change the default behavior
aerial = require("aerial")
aerial.setup({
  -- Priority list of preferred backends for aerial.
  -- This can be a filetype map (see :help aerial-filetype-map)
  backends = {
    "treesitter", 
    -- "lsp",
    "markdown", 
    "man"
  },

  layout = {
    -- These control the width of the aerial window.
    -- They can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
    -- min_width and max_width can be a list of mixed types.
    -- max_width = {40, 0.2} means "the lesser of 40 columns or 20% of total"
    max_width = { 80, 0.5 },
    width = nil,
    min_width = 20,

    -- key-value pairs of window-local options for aerial window (e.g. winhl)
    win_opts = {
      winblend = 30,
    },

    -- Determines the default direction to open the aerial window. The 'prefer'
    -- options will open the window in the other direction *if* there is a
    -- different buffer in the way of the preferred direction
    -- Enum: prefer_right, prefer_left, right, left, float
    default_direction = "float",

    -- Determines where the aerial window will be opened
    --   edge   - open aerial at the far right/left of the editor
    --   window - open aerial to the right/left of the current window
    placement = "edge",

    -- Preserve window size equality with (:help CTRL-W_=)
    preserve_equality = false,
  },

  -- Determines how the aerial window decides which buffer to display symbols for
  --   window - aerial window will display symbols for the buffer in the window from which it was opened
  --   global - aerial window will display symbols for the current window
  -- attach_mode = "window",

  -- List of enum values that configure when to auto-close the aerial window
  --   unfocus       - close aerial when you leave the original source window
  --   switch_buffer - close aerial when you change buffers in the source window
  --   unsupported   - close aerial when attaching to a buffer that has no symbol source
  -- close_automatic_events = {},

  -- Keymaps in aerial window. Can be any value that `vim.keymap.set` accepts OR a table of keymap
  -- options with a `callback` (e.g. { callback = function() ... end, desc = "", nowait = true })
  -- Additionally, if it is a string that matches "actions.<name>",
  -- it will use the mapping at require("aerial.actions").<name>
  -- Set to `false` to remove a keymap
  -- keymaps = {
  --   ["?"] = "actions.show_help",
  --   ["g?"] = "actions.show_help",
  --   ["<CR>"] = "actions.jump",
  --   ["<2-LeftMouse>"] = "actions.jump",
  --   ["<C-v>"] = "actions.jump_vsplit",
  --   ["<C-s>"] = "actions.jump_split",
  --   ["p"] = "actions.scroll",
  --   ["<C-j>"] = "actions.down_and_scroll",
  --   ["<C-k>"] = "actions.up_and_scroll",
  --   ["{"] = "actions.prev",
  --   ["}"] = "actions.next",
  --   ["[["] = "actions.prev_up",
  --   ["]]"] = "actions.next_up",
  --   ["q"] = "actions.close",
  --   ["o"] = "actions.tree_toggle",
  --   ["za"] = "actions.tree_toggle",
  --   ["O"] = "actions.tree_toggle_recursive",
  --   ["zA"] = "actions.tree_toggle_recursive",
  --   ["l"] = "actions.tree_open",
  --   ["zo"] = "actions.tree_open",
  --   ["L"] = "actions.tree_open_recursive",
  --   ["zO"] = "actions.tree_open_recursive",
  --   ["h"] = "actions.tree_close",
  --   ["zc"] = "actions.tree_close",
  --   ["H"] = "actions.tree_close_recursive",
  --   ["zC"] = "actions.tree_close_recursive",
  --   ["zr"] = "actions.tree_increase_fold_level",
  --   ["zR"] = "actions.tree_open_all",
  --   ["zm"] = "actions.tree_decrease_fold_level",
  --   ["zM"] = "actions.tree_close_all",
  --   ["zx"] = "actions.tree_sync_folds",
  --   ["zX"] = "actions.tree_sync_folds",
  -- },

  -- When true, don't load aerial until a command or function is called
  -- Defaults to true, unless `on_attach` is provided, then it defaults to false
  -- lazy_load = true,

  -- Disable aerial on files with this many lines
  disable_max_lines = 100000,

  -- Disable aerial on files this size or larger (in bytes)
  disable_max_size = 2000000, -- Default 2MB

  -- A list of all symbols to display. Set to false to display all symbols.
  -- This can be a filetype map (see :help aerial-filetype-map)
  -- To see all available values, see :help SymbolKind
  filter_kind = {
    "Class",
    "Constructor",
    "Enum",
    "Function",
    "Interface",
    "Module",
    "Method",
    "Struct",
  },

  -- Determines line highlighting mode when multiple splits are visible.
  -- split_width   Each open window will have its cursor location marked in the
  --               aerial buffer. Each line will only be partially highlighted
  --               to indicate which window is at that location.
  -- full_width    Each open window will have its cursor location marked as a
  --               full-width highlight in the aerial buffer.
  -- last          Only the most-recently focused window will have its location
  --               marked in the aerial buffer.
  -- none          Do not show the cursor locations in the aerial window.
  highlight_mode = "last",

  -- Highlight the closest symbol if the cursor is not exactly on one.
  -- highlight_closest = true,

  -- Highlight the symbol in the source buffer when cursor is in the aerial win
  -- highlight_on_hover = false,

  -- When jumping to a symbol, highlight the line for this many ms.
  -- Set to false to disable
  -- highlight_on_jump = 300,

  -- Define symbol icons. You can also specify "<Symbol>Collapsed" to change the
  -- icon when the tree is collapsed at that symbol, or "Collapsed" to specify a
  -- default collapsed icon. The default icon set is determined by the
  -- "nerd_font" option below.
  -- If you have lspkind-nvim installed, it will be the default icon set.
  -- This can be a filetype map (see :help aerial-filetype-map)
  -- icons = {},

  -- Control which windows and buffers aerial should ignore.
  -- Aerial will not open when these are focused, and existing aerial windows will not be updated
  -- ignore = {
  --   -- Ignore unlisted buffers. See :help buflisted
  --   unlisted_buffers = false,

  --   -- List of filetypes to ignore.
  --   filetypes = {},

  --   -- Ignored buftypes.
  --   -- Can be one of the following:
  --   -- false or nil - No buftypes are ignored.
  --   -- "special"    - All buffers other than normal and help buffers are ignored.
  --   -- table        - A list of buftypes to ignore. See :help buftype for the
  --   --                possible values.
  --   -- function     - A function that returns true if the buffer should be
  --   --                ignored or false if it should not be ignored.
  --   --                Takes two arguments, `bufnr` and `buftype`.
  --   buftypes = "special",

  --   -- Ignored wintypes.
  --   -- Can be one of the following:
  --   -- false or nil - No wintypes are ignored.
  --   -- "special"    - All windows other than normal windows are ignored.
  --   -- table        - A list of wintypes to ignore. See :help win_gettype() for the
  --   --                possible values.
  --   -- function     - A function that returns true if the window should be
  --   --                ignored or false if it should not be ignored.
  --   --                Takes two arguments, `winid` and `wintype`.
  --   wintypes = "special",
  -- },

  -- Use symbol tree for folding. Set to true or false to enable/disable
  -- Set to "auto" to manage folds if your previous foldmethod was 'manual'
  -- This can be a filetype map (see :help aerial-filetype-map)
  manage_folds = false,

  -- When you fold code with za, zo, or zc, update the aerial tree as well.
  -- Only works when manage_folds = true
  link_folds_to_tree = false,

  -- Fold code when you open/collapse symbols in the tree.
  -- Only works when manage_folds = true
  link_tree_to_folds = true,

  -- Set default symbol icons to use patched font icons (see https://www.nerdfonts.com/)
  -- "auto" will set it to true if nvim-web-devicons or lspkind-nvim is installed.
  nerd_font = "auto",

  -- Call this function when aerial attaches to a buffer.
  -- on_attach = function(bufnr) end,

  -- Call this function when aerial first sets symbols on a buffer.
  -- on_first_symbols = function(bufnr) end,

  -- Automatically open aerial when entering supported buffers.
  -- This can be a function (see :help aerial-open-automatic)
  -- open_automatic = false,

  -- Run this command after jumping to a symbol (false will disable)
  -- post_jump_cmd = "normal! zz",

  -- Invoked after each symbol is parsed, can be used to modify the parsed item,
  -- or to filter it by returning false.
  --
  -- bufnr: a neovim buffer number
  -- item: of type aerial.Symbol
  -- ctx: a record containing the following fields:
  --   * backend_name: treesitter, lsp, man...
  --   * lang: info about the language
  --   * symbols?: specific to the lsp backend
  --   * symbol?: specific to the lsp backend
  --   * syntax_tree?: specific to the treesitter backend
  --   * match?: specific to the treesitter backend, TS query match
  post_parse_symbol = function(bufnr, item, ctx)
    return true
  end,

  -- Invoked after all symbols have been parsed and post-processed,
  -- allows to modify the symbol structure before final display
  --
  -- bufnr: a neovim buffer number
  -- items: a collection of aerial.Symbol items, organized in a tree,
  --        with 'parent' and 'children' fields
  -- ctx: a record containing the following fields:
  --   * backend_name: treesitter, lsp, man...
  --   * lang: info about the language
  --   * symbols?: specific to the lsp backend
  --   * syntax_tree?: specific to the treesitter backend
  post_add_all_symbols = function(bufnr, items, ctx)
    return items
  end,

  -- When true, aerial will automatically close after jumping to a symbol
  close_on_select = true,

  -- The autocmds that trigger symbols update (not used for LSP backend)
  -- update_events = "TextChanged,InsertLeave",

  -- Show box drawing characters for the tree hierarchy
  show_guides = true,

  -- Customize the characters used when show_guides = true
  -- guides = {
  --   -- When the child item has a sibling below it
  --   mid_item = "├─",
  --   -- When the child item is the last in the list
  --   last_item = "└─",
  --   -- When there are nested child guides to the right
  --   nested_top = "│ ",
  --   -- Raw indentation
  --   whitespace = "  ",
  -- },

  -- Set this function to override the highlight groups for certain symbols
  -- get_highlight = function(symbol, is_icon)
  --   -- return "MyHighlight" .. symbol.kind
  -- end,

  -- Options for opening aerial in a floating win
  float = {
    -- Controls border appearance. Passed to nvim_open_win
    border = "rounded",

    -- Determines location of floating window
    --   cursor - Opens float on top of the cursor
    --   editor - Opens float centered in the editor
    --   win    - Opens float centered in the window
    relative = "win",

    -- These control the height of the floating window.
    -- They can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
    -- min_height and max_height can be a list of mixed types.
    -- min_height = {8, 0.1} means "the greater of 8 rows or 10% of total"
    max_height = 0.9,
    height = nil,
    min_height = { 8, 0.1 },

    override = function(conf, source_winid)
      -- This is the config that will be passed to nvim_open_win.
      -- Change values here to customize the layout
      conf.anchor = "NE"
      conf.col = vim.fn.winwidth(source_winid)
      conf.row = 0
      return conf
    end,
  },

  -- lsp = {
  --   -- Fetch document symbols when LSP diagnostics update.
  --   -- If false, will update on buffer changes.
  --   diagnostics_trigger_update = true,

  --   -- Set to false to not update the symbols when there are LSP errors
  --   update_when_errors = true,

  --   -- How long to wait (in ms) after a buffer change before updating
  --   -- Only used when diagnostics_trigger_update = false
  --   update_delay = 300,

  --   -- Map of LSP client name to priority. Default value is 10.
  --   -- Clients with higher (larger) priority will be used before those with lower priority.
  --   -- Set to -1 to never use the client.
  --   priority = {
  --     -- pyright = 10,
  --   },
  -- },

  treesitter = {
    -- How long to wait (in ms) after a buffer change before updating
    update_delay = 300,
  },

  markdown = {
    -- How long to wait (in ms) after a buffer change before updating
    update_delay = 300,
  },

  man = {
    -- How long to wait (in ms) after a buffer change before updating
    update_delay = 300,
  },

})
vim.keymap.set("n", "<leader>ot", function()
  aerial.toggle { focus = false }
  aerial.focus()
end)
'''
